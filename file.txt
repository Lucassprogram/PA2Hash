A concurrent hash table is a data structure that allows multiple threads to perform operations on a shared collection of key-data pairs, without causing data corruption or inconsistency. The concurrent hash table consists of a linked list of nodes, each of which stores some data associated with the key. The hash value is computed by applying a hash function to the key.

Note that for this assignment, we will not be taking into consideration hash collisions. We will use Jenkins's one_at_a_time hash function

Links to an external site.

Links to an external site.

Links to an external site. which has a very low collision rate for the number of hashes we will be working with. Regardless, your test data and the final data set you will be graded against will be guaranteed collision-free.

The concurrent hash table supports the following functions:

    insert(key, values): This function inserts a new key-data pair into the hash table, or updates the value of an existing key. To insert a key-data pair, the function first computes the hash value of the given name (the key).  Then, it acquires the write lock that protects the list and searches the linked list for the hash. If the hash is found, it updates the value. Otherwise, it creates a new node and inserts it in the list. Finally, it releases the write lock and returns.
    delete(key): This function deletes a key-data pair from the hash table, if it exists. To delete a key-data pair, the function first computes the hash value of the key and obtains a writer lock. Then it searches the linked list for the key. If the key is found, it removes the node from the list and frees the memory. Otherwise, it does nothing. Finally, it releases the write lock and returns.
    updateSalary(key, value): This function takes a key and an integer value.  If it finds a node with a matching key, it updates the salary field with the given value.
    search(key): This function searches for a key-data pair in the hash table and returns the value, if it exists. To search for a key-data pair, the function first computes the hash value of the key acquires a reader lock. Then, it searches the linked list for the key. If the key is found, it returns the value. Otherwise, it returns NULL. Finally, it releases the read lock and returns. The caller should then print the record or "No Record Found" if the return is NULL.

The Hash Table Structure

typedef struct hash_struct
{
  uint32_t hash;
  char name[50];
  uint32_t salary;
  struct hash_struct *next;
} hashRecord;

Field 	Description
hash 	32-bit unsigned integer for the hash value produced by running the name text through the Jenkins one-at-a-time function
Links to an external site.
name 	Arbitrary string up to 50 characters long
salary 	32-bit unsigned integer (who wants a negative salary, eh?) to represent an annual salary.
next 	Pointer to the next record
Reader-Writer Lock Reference

The OSTEP authors have provided sample implementations that you should reference:

https://github.com/remzi-arpacidusseau/ostep-code/tree/master/threads-sema

Links to an external site.
The Command File

Your program must read a text file called commands.txt containing some configuration information, commands, and data values. Do not read it from the console. You should hard code "commands.txt" into your program.
List of Commands and their parameters
Command 	Parameters 	Description
insert 	<name>,<salary>,<priority> 	inserts or updates the data for the given name and salary value.
delete 	<name>,<priority> 	Name whose record is to be deleted from the list.
search 	<name>,<priority> 	Name whose record is to be retrieved and printed to the output file.
print 	<priority> 	Print the entire contents of the list to the output file.
Sample Command File

insert,Richard Garriot,40000,1  
insert,Sid Meier,50000,2  
insert,Shigeru Miyamoto,51000,3  
delete,Sid Meier,4  
insert,Hideo Kojima,45000,5  
insert,Gabe Newell,49000,6  
insert,Roberta Williams,45900,7  
delete,Richard Garriot,8  
insert,Carol Shaw,41000,9  
search,Sid Meier,10

Expected Output

Output should be written to a file called output.txt in the same directory as the main chash program and the commands.txt file.
Log File (hash.log)

Write out each command as they're executed, along with their parameters in this format:
<timestamp>,THREAD <priority>,<command and parameters>

You will also write out when locks are acquired and released:
<timestamp>,THREAD <priority>WAITING FOR MY TURN
<timestamp>,THREAD <priority>AWAKENED FOR WORK
<timestamp>,THREAD <priority>READ LOCK ACQUIRED
<timestamp>,THREAD <priority>READ LOCK RELEASED
<timestamp>,THREAD <priority>WRITE LOCK ACQUIRED
<timestamp>,THREAD <priority>WRITE LOCK RELEASED

You can use the following function to obtain accurate timing values:

#include "sys/time.h"

long long current_timestamp() {  
  struct timeval te;  
  gettimeofday(&te, NULL); // get current time  
  long long microseconds = (te.tv_sec * 1000000) + te.tv_usec; // calculate milliseconds  
  return microseconds;  
} 

Sample output looks something like this:

1721428978841092: INSERT,2569965317,Hideo Kojima,45000   
1721428978841096: WRITE LOCK ACQUIRED   
1721428978841098: WRITE LOCK RELEASED

Console Output (i.e. stdout)

Each command will provide some form of user feedback as follows:
Command 	Output
INSERT 	Inserted <values>
UPDATE 	Updated record <hash> from <old values> to <new values>
DELETE 	Deleted record for <values>
SEARCH 	Found: <values>
PRINT 	Current Database:
<all records in the database, sorted by hash>

NOTE:

    Only the final list print should look just like mine.  The exact ordering of thread execution will be random, as we've discussed in class.
    The delete function may incur one or two sets of lock operations, depending on your implementation:
        If you use the search function you already wrote to find the record to delete, you will have two sets of lock operations -- the outer lock for the delete and the inner one for the search.
        Otherwise, you'll just have one set of operations.

Final Deliverables:
Filename 	Purpose
chash.c 	Your main program that reads the commands.txt and produces output to the console
Makefile 	Your Makefile that builds this project into the final executable.  Make your code modular, use multiple source files!
Other Source Files 	Any additional source files that you used in your program.  Please don't write a monolithic chash.c!
README.txt 	Use for anything I or my graders need to know and the AI use citation (see below)
All of these should be uploaded as a single zip file containing all of the files.
We should be able to:

    Unzip your file.
    Run make to compile it into the main executable chash
    Your program will read commands.txt and then produce hash.log and console output for the product of each command.
